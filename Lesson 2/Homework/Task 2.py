"""
Реализуйте одну очень странную нейросеть. Нейросеть должна:

1. принимать на вход вектор признаков (чисел с плавающей точкой);
2. в качестве первого преобразования умножать вектор признаков на матрицу весов A2 (на выходе получается новый вектор);
3. в качестве второго преобразования умножать вектор, полученный на прошлом шаге,
на вектор весов b (на выходе получается скалярное число).

Размерности матриц и векторов - в пределах 1024.


Формат входных данных
В первой строке приходит путь к файлу, в котором хранится матрица весов A размерности NxM.
Файл содержит N строк в каждой по M значений через пробел. Каждое значение - число с плавающей точкой.

Чтобы получить матрицу A2 для первого преобразования, нужно возвести данную матрицу A в квадрат.

Во второй строке приходит путь к файлу, в котором хранится вектор весов b.
Файл содержит одну строку с N значениями через пробел. Каждое значение - число с плавающей точкой.

В третьей строке приходит входной вектор X. Формат строки - M значений с плавающей точкой через пробел.


Формат выходных данных
Одно число - результат прохождения вектора X через нашу странную нейросеть.
Число выводить со всеми знаками после запятой, какие получатся.

Ремарка: чтобы это было более похоже на нейросеть, можно было сказать,
что слоёв у вас штуки так три, в первом используется A, во втором - квадрат A, в третьем - куб А.
Но в режиме контрольной не будем усложнять.
"""

import pandas as pd
import numpy as np

path_A = str(input())
path_B = str(input())
vector = np.array(list(map(float, input().split())))
df_A = pd.read_csv(path_A, header=None, sep=" ")
df_B = pd.read_csv(path_B, header=None, sep=" ")
# print(df_A.values)
# print(df_A.values[0][0])
# print(df_A.values.shape)
a_2 = df_A @ df_A
# print(a_2)
# print(vector)
step_1 = a_2 @ vector
# print(step_1)
# print(df_B)
step_2 = step_1.values.reshape((1,3)) @ df_B.values.reshape((3, 1))
print(float(step_2))


'''A.dat
B.dat
0.5 0.1 0.5'''
